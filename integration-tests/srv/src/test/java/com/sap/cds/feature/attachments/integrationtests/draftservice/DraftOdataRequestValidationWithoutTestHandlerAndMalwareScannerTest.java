/*
 * Â© 2024-2025 SAP SE or an SAP affiliate company and cds-feature-attachments contributors.
 */
package com.sap.cds.feature.attachments.integrationtests.draftservice;

import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;
import static com.github.tomakehurst.wiremock.client.WireMock.post;
import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;
import static org.assertj.core.api.Assertions.assertThat;

import com.github.tomakehurst.wiremock.WireMockServer;
import com.sap.cds.feature.attachments.integrationtests.common.MalwareScanResultProvider;
import com.sap.cds.feature.attachments.integrationtests.constants.Profiles;
import java.util.concurrent.TimeUnit;
import org.awaitility.Awaitility;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ActiveProfiles;
import org.wiremock.spring.ConfigureWireMock;
import org.wiremock.spring.EnableWireMock;
import org.wiremock.spring.InjectWireMock;

@ActiveProfiles(profiles = {Profiles.TEST_HANDLER_DISABLED, Profiles.MALWARE_SCAN_ENABLED})
@EnableWireMock({@ConfigureWireMock(port = 1111, name = "malware-scanner")})
class DraftOdataRequestValidationWithoutTestHandlerAndMalwareScannerTest
    extends DraftOdataRequestValidationWithoutTestHandlerAndWithoutMalwareScannerTest {

  private static final Logger logger =
      LoggerFactory.getLogger(
          DraftOdataRequestValidationWithoutTestHandlerAndMalwareScannerTest.class);

  @InjectWireMock("malware-scanner")
  private WireMockServer wiremock;

  @Autowired private MalwareScanResultProvider malwareScanResultProvider;

  @BeforeEach
  void setup() {
    mockMalwareScanResult(false);
  }

  @Override
  @AfterEach
  void teardown() {
    super.teardown();
    wiremock.resetAll();
  }

  @Test
  void contentCanNotBeReadForActiveRoot() throws Exception {
    wiremock.resetAll();
    mockMalwareScanResult(true);
    var attachmentContent = "attachment Content";
    var attachmentEntityContent = "attachmentEntity Content";
    var selectedRoot = deepCreateAndActivate(attachmentContent, attachmentEntityContent);
    clearServiceHandlerContext();

    var attachmentUrl =
        getAttachmentBaseUrl(
                selectedRoot.getItems().get(0).getId(),
                selectedRoot.getItems().get(0).getAttachments().get(0).getId(),
                true)
            + "/content";
    var attachmentEntityUrl =
        getAttachmentEntityBaseUrl(
                selectedRoot.getItems().get(0).getAttachmentEntities().get(0).getId(), true)
            + "/content";

    Awaitility.await()
        .atMost(60, TimeUnit.SECONDS)
        .pollDelay(1, TimeUnit.SECONDS)
        .until(
            () -> {
              var attachmentResponse = requestHelper.executeGet(attachmentUrl);
              var attachmentEntityResponse = requestHelper.executeGet(attachmentEntityUrl);

              var attachmentResponseContent = attachmentResponse.getResponse().getContentAsString();
              var attachmentEntityResponseContent =
                  attachmentEntityResponse.getResponse().getContentAsString();

              logger.info(
                  "Status should contain 'not_clean' for attachment and attachment entity but was: {} for attachment and {} for attachment entity",
                  attachmentResponseContent,
                  attachmentEntityResponseContent);

              return attachmentResponseContent.contains("not_clean")
                  && attachmentEntityResponseContent.contains("not_clean");
            });
    clearServiceHandlerContext();

    var attachmentResponse = requestHelper.executeGet(attachmentUrl);
    var attachmentEntityResponse = requestHelper.executeGet(attachmentEntityUrl);

    assertThat(attachmentResponse.getResponse().getContentAsString())
        .contains("Error text for not clean");
    assertThat(attachmentEntityResponse.getResponse().getContentAsString())
        .contains("Error text for not clean");
    verifyTwoReadEvents();
  }

  private void mockMalwareScanResult(boolean malware) {
    wiremock.stubFor(
        post(urlEqualTo("/scan"))
            .withBasicAuth("test-user", "test-password")
            .willReturn(
                aResponse()
                    .withBody(malwareScanResultProvider.buildMalwareScanResult(malware))
                    .withStatus(200)));
  }
}
