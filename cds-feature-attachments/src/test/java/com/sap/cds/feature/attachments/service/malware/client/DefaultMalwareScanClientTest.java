package com.sap.cds.feature.attachments.service.malware.client;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Objects;

import org.apache.http.Header;
import org.apache.http.HeaderElement;
import org.apache.http.HttpEntity;
import org.apache.http.StatusLine;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
import org.apache.http.message.BasicHeaderElement;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.ArgumentCaptor;

import com.sap.cds.feature.attachments.service.malware.client.httpclient.HttpClientProviderFactory;
import com.sap.cds.feature.attachments.service.malware.client.model.MalwareScanResultStatus;
import com.sap.cds.services.ServiceException;

class DefaultMalwareScanClientTest {

	private DefaultMalwareScanClient cut;
	private HttpClientProviderFactory clientProviderFactory;
	private ArgumentCaptor<HttpEntityEnclosingRequestBase> requestCaptor;

	@BeforeEach
	void setup() {
		clientProviderFactory = mock(HttpClientProviderFactory.class);
		cut = new DefaultMalwareScanClient(clientProviderFactory);

		requestCaptor = ArgumentCaptor.forClass(HttpEntityEnclosingRequestBase.class);
	}

	@Test
	void noServiceBoundReturnsCorrectStatus() {
		when(clientProviderFactory.isServiceBound()).thenReturn(false);

		var result = cut.scanContent(mock(InputStream.class));

		assertThat(result).isEqualTo(MalwareScanResultStatus.NO_SCANNER);
		verify(clientProviderFactory, never()).getHttpClient();
	}

	@Test
	void contentIsUsedInRequest() throws IOException {
		var content = mock(InputStream.class);
		var httpClient = mockHttpResponse(200, false, false);

		cut.scanContent(content);

		verify(httpClient).execute(requestCaptor.capture());
		assertThat(requestCaptor.getValue().getEntity().getContent()).isEqualTo(content);
	}

	@Test
	void correctMethodIsUsedInRequest() throws IOException {
		var content = mock(InputStream.class);
		var httpClient = mockHttpResponse(200, false, false);

		cut.scanContent(content);

		verify(httpClient).execute(requestCaptor.capture());
		var request = requestCaptor.getValue();
		assertThat(request.getMethod()).isEqualTo("POST");
	}

	@Test
	void correctStatusReturnedForSuccessfulScan() throws IOException {
		mockHttpResponse(200, false, false);

		var response = cut.scanContent(mock(InputStream.class));

		assertThat(response).isEqualTo(MalwareScanResultStatus.CLEAN);
	}

	@ParameterizedTest
	@CsvSource({"true, false", "false, true", "true, true"})
	void correctStatusReturnedForNotCleanResponse(boolean malwareDetected,
			boolean encryptedContentDetected) throws IOException {
		mockHttpResponse(200, malwareDetected, encryptedContentDetected);

		var response = cut.scanContent(mock(InputStream.class));

		assertThat(response).isEqualTo(MalwareScanResultStatus.INFECTED);
	}

	@Test
	void exceptionIsThrownIfRequestRespondWithException() throws IOException {
		when(clientProviderFactory.isServiceBound()).thenReturn(true);
		var httpClient = mock(HttpClient.class);
		when(clientProviderFactory.getHttpClient()).thenReturn(httpClient);
		when(httpClient.execute(any())).thenThrow(new IOException());

		var inputStream = mock(InputStream.class);
		assertThrows(ServiceException.class, () -> cut.scanContent(inputStream));
	}

	@ParameterizedTest
	@ValueSource(ints = {100, 199, 208, 300, 400, 500})
	void exceptionIsThrownIfRequestRespondWithNon200StatusCode(int status) throws IOException {
		mockHttpResponse(status, false, false);

		var inputStream = mock(InputStream.class);
		assertThrows(ServiceException.class, () -> cut.scanContent(inputStream));
	}

	@Test
	void exceptionIsThrownIfRequestRespondWithNonJsonContentType() throws IOException {
		mockHttpResponse(200, false, false, "text/plain", true);

		var inputStream = mock(InputStream.class);
		assertThrows(ServiceException.class, () -> cut.scanContent(inputStream));
	}

	@Test
	void noExceptionIfCorrectContentType() throws IOException {
		mockHttpResponse(200, false, false, "application/json", true);

		var inputStream = mock(InputStream.class);
		assertDoesNotThrow(() -> cut.scanContent(inputStream));
	}

	@Test
	void noResponseEntityReturnsClean() throws IOException {
		mockHttpResponse(200, false, false, "application/json", false);

		var response = cut.scanContent(mock(InputStream.class));

		assertThat(response).isEqualTo(MalwareScanResultStatus.CLEAN);
	}

	private HttpClient mockHttpResponse(int httpStatus, boolean malwareDetected,
			boolean encryptedContentDetected) throws IOException {
		return mockHttpResponse(httpStatus, malwareDetected, encryptedContentDetected, null, true);
	}

	private HttpClient mockHttpResponse(int httpStatus, boolean malwareDetected, boolean encryptedContentDetected,
			String contentTypeString, boolean responseEntityExists) throws IOException {
		when(clientProviderFactory.isServiceBound()).thenReturn(true);
		var httpClient = mock(HttpClient.class);
		when(clientProviderFactory.getHttpClient()).thenReturn(httpClient);
		var response = mock(CloseableHttpResponse.class);
		when(httpClient.execute(any())).thenReturn(response);
		var statusLine = mock(StatusLine.class);
		when(response.getStatusLine()).thenReturn(statusLine);
		when(statusLine.getStatusCode()).thenReturn(httpStatus);
		if (responseEntityExists) {
			var entity = mock(HttpEntity.class);
			when(response.getEntity()).thenReturn(entity);
			when(entity.getContent()).thenReturn(new ByteArrayInputStream(
					getJsonResponse(malwareDetected, encryptedContentDetected).getBytes(StandardCharsets.UTF_8)));
			if (Objects.nonNull(contentTypeString)) {
				var contentType = mock(Header.class);
				when(contentType.getValue()).thenReturn(contentTypeString);
				when(contentType.getElements()).thenReturn(new HeaderElement[]{new BasicHeaderElement("charset", "utf-8")});
				when(entity.getContentType()).thenReturn(contentType);
			}
		}
		return httpClient;
	}

	private String getJsonResponse(boolean malwareDetected, boolean encryptedContentDetected) {
		return """
				{
				\t"malwareDetected": %s,
				\t"encryptedContentDetected": %s,
				\t"scanSize": 0,
				\t"finding": "Win.Test.EICAR_HDB-1",
				\t"mimeType": "text/plain",
				\t"SHA256": "275a021bbfb6489e54d471899f7db9d1663fc695ec2fe2a2c4538aabf651fd0f",
				\t"extensions": [
				\t\t"txt"
				\t]
				}""".formatted(malwareDetected, encryptedContentDetected);
	}

}
