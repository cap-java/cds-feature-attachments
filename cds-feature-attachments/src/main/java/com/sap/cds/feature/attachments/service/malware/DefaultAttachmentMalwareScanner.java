/**************************************************************************
 * (C) 2019-2025 SAP SE or an SAP affiliate company. All rights reserved. *
 **************************************************************************/
package com.sap.cds.feature.attachments.service.malware;

import static java.util.Objects.requireNonNull;

import java.io.InputStream;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.annotations.VisibleForTesting;
import com.sap.cds.Result;
import com.sap.cds.feature.attachments.generated.cds4j.sap.attachments.Attachments;
import com.sap.cds.feature.attachments.generated.cds4j.sap.attachments.StatusCode;
import com.sap.cds.feature.attachments.service.AttachmentService;
import com.sap.cds.feature.attachments.service.malware.client.MalwareScanClient;
import com.sap.cds.feature.attachments.service.malware.client.MalwareScanResultStatus;
import com.sap.cds.ql.Select;
import com.sap.cds.ql.Update;
import com.sap.cds.ql.cqn.CqnSelect;
import com.sap.cds.ql.cqn.CqnUpdate;
import com.sap.cds.reflect.CdsElementNotFoundException;
import com.sap.cds.reflect.CdsEntity;
import com.sap.cds.services.draft.Drafts;
import com.sap.cds.services.persistence.PersistenceService;

/**
 * The given input stream is scanned by using the malware scan service. The result of the scan is returned with status
 * {@link MalwareScanResultStatus}. In case of draft entity the data are tried to read from the draft entity first and
 * if nothing is found the data are read from the main entity.
 */
public class DefaultAttachmentMalwareScanner implements AttachmentMalwareScanner {

	/**
	 * The name or label of the Malware Scan Service binding.
	 */
	public static final String MALWARE_SCAN_SERVICE_LABEL = "malware-scanner";

	private static final Logger logger = LoggerFactory.getLogger(DefaultAttachmentMalwareScanner.class);

	private final PersistenceService persistenceService;
	private final AttachmentService attachmentService;
	private final MalwareScanClient malwareScanClient;

	/**
	 * Constructs a new instance of {@link DefaultAttachmentMalwareScanner} and initializes it with the required
	 * services.
	 *
	 * @param persistenceService the required {@link PersistenceService} instance
	 * @param attachmentService  the required {@link AttachmentService} instance
	 * @param malwareScanClient  an optional {@link MalwareScanClient} instance
	 *
	 * @throws NullPointerException if any of the required services are null
	 */
	public DefaultAttachmentMalwareScanner(PersistenceService persistenceService, AttachmentService attachmentService,
			MalwareScanClient malwareScanClient) {
		this.persistenceService = requireNonNull(persistenceService, "persistenceService must not be null");
		this.attachmentService = requireNonNull(attachmentService, "attachmentService must not be null");
		this.malwareScanClient = malwareScanClient;
	}

	@Override
	public void scanAttachment(CdsEntity attachmentEntity, String contentId) {
		logger.debug("Started scanning attachment {} of entity {}.", contentId, attachmentEntity.getQualifiedName());

		List<SelectionResult> selectionResult = selectData(attachmentEntity, contentId);

		selectionResult.forEach(result -> {

			long rowCount = result.result().rowCount();
			if (rowCount <= 0) {
				logger.debug("No attachments {} found in entity {}, nothing to scan.", contentId,
						result.entity.getQualifiedName());
				return;
			}

			if (rowCount > 1) {
				logger.warn("More than one attachment {} found in entity {}.", contentId,
						result.entity.getQualifiedName());
				throw new IllegalStateException("More than one attachment with contentId %s.".formatted(contentId));
			}

			Attachments attachment = result.result().single(Attachments.class);
			MalwareScanResultStatus status = scanDocument(attachment);
			updateData(result.entity, contentId, status);
		});

	}

	private List<SelectionResult> selectData(CdsEntity attachmentEntity, String contentId) {
		List<SelectionResult> result = new ArrayList<>();
		try {
			CdsEntity entity = (CdsEntity) attachmentEntity.getTargetOf(Drafts.SIBLING_ENTITY);
			Result selectionResult = readData(contentId, entity);
			result.add(new SelectionResult(entity, selectionResult));
		} catch (CdsElementNotFoundException ignored) {
			// no sibling found nothing to select
		}
		Result selectionResult = readData(contentId, attachmentEntity);
		result.add(new SelectionResult(attachmentEntity, selectionResult));

		return result;
	}

	private Result readData(String contentId, CdsEntity entity) {
		CqnSelect select = Select.from(entity).columns(Attachments.CONTENT_ID, Attachments.CONTENT, Attachments.STATUS)
				.where(e -> e.get(Attachments.CONTENT_ID).eq(contentId)
						.and(e.get(Attachments.STATUS).ne(StatusCode.CLEAN)));

		Result result = persistenceService.run(select);
		result.streamOf(Attachments.class)
				.forEach(attachment -> logger.debug("Found attachment {} in entity {} with status {}.",
						attachment.getContentId(), entity.getQualifiedName(), attachment.getStatus()));
		return result;
	}

	private MalwareScanResultStatus scanDocument(Attachments attachment) {
		if (malwareScanClient != null) {
			try {
				InputStream content = Objects.nonNull(attachment.getContent()) ? attachment.getContent()
						: attachmentService.readAttachment(attachment.getContentId());
				logger.debug("Start scanning attachment {}.", attachment.getContentId());
				return malwareScanClient.scanContent(content);
			} catch (RuntimeException e) {
				logger.error("Error while scanning attachment {}.", attachment.getContentId(), e);
				return MalwareScanResultStatus.FAILED;
			}
		}
		return MalwareScanResultStatus.NO_SCANNER;
	}

	private void updateData(CdsEntity attachmentEntity, String contentId, MalwareScanResultStatus status) {
		Attachments updateData = Attachments.create();
		updateData.setStatus(mapStatus(status));
		updateData.setScannedAt(Instant.now());

		CqnUpdate update = Update.entity(attachmentEntity).data(updateData)
				.where(entry -> entry.get(Attachments.CONTENT_ID).eq(contentId));
		Result result = persistenceService.run(update);

		logger.debug("Updated scan status to {} of attachment {} in entity {} -> Row count {}.", updateData.getStatus(),
				contentId, attachmentEntity.getQualifiedName(), result.rowCount());
	}

	@VisibleForTesting
	static String mapStatus(MalwareScanResultStatus status) {
		return switch (status) {
		case CLEAN, NO_SCANNER -> StatusCode.CLEAN;
		case INFECTED, ENCRYPTED -> StatusCode.INFECTED;
		default -> StatusCode.FAILED;
		};
	}

	private record SelectionResult(CdsEntity entity, Result result) {
	}

}
